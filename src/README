Ignatescu Darius Bogdan, Grupa 331CB

Semnificatie tipuri de date si variabile

--> struct tracker_file : retine datele unui fisier din perspectiva trackerului: nr de owneri, care sunt, hashurile fisierelor in ordine si numele fisierelor

--> struct client_file: retine un fisier asa cum il are clientul(complet sau partial la un moment dat de timp) : nume fisier, cate segmente are clientul din fisier, cate segmente are fisierul complet si lista de segmente detinute din acel fisier la un moment dat de catre clientul respectiv

-> struct file_swarm: este folosit pentru comunicarea intre threadul de download al clientului si tracker. Mesajele pot fi de 4 tipuri: cerere de swarm,actualizare, informare despre descarcarea unui fisier sau informarea despre descarcarea tuturor fisierelor. Intrucat un swarm valid poate avea doar numar pozitiv de owneri(seeds sau peers), atunci cand trimit cererea de la download_thread_func catre tracker,in campul nr_peers pun unul din urmatoarele coduri pentru identificarea tipului de mesaj: CLIENT_DOWNLOADED_ALL_FILES = -1, CLIENT_DOWNLOADED_ONE_FILE -2, SWARM_REQUEST -7000 sau UPDATE_REQUEST = -7567. Atunci cand trackerul primeste bufferul de tip struct file_swarm, va pune datele aferente raspunsului cererii in acesta, va suprascrie codul pe care l-a dat trackerul pentru identificarea mesajului si va trimite in download datele corecte(doar pentru cereri de swarm / actualizare, mesajele care desemneaza informarea trackerului nu necesita raspuns).

-> struct client_request: este folosit pentru cereri de segmente si raspunsurile aferente (aceste schimburi de cereri si raspunsuri au loc
intre functia de download a unui client si cea de upload a altui client) sau pentru mesajul de la tracker care ii spune threadului de upload sa se opreasca. De vreme ce trackerul nu descarca, deci nu face cereri de segmente, singura situatie cand sursa unui mesaj este trackerul este cea in care trebuie oprit threadul de upload. Daca sursa nu e trackerul, inseamna ca e cerere normala de segment.

-> my_files: retine fisierele clientului(pot fi detinute complet sau partial la un moment dat de timp)

-> wanted_files: coada care retine numele fisierelor pe care clientul doreste sa le descarce

Explicatii mod de functionare al functiilor:

--> void read_file(int rank): citeste datele despre fisierele pe care un client le detine complet(este seed), respectiv pe care le doreste. Daca fisierul e detinut complet, datele acestuia sunt atat retinute de client din perspectiva sa, cat si trimise catre tracker. Daca fisierul este dorit, datele acestuia sunt tinute minte doar de client(datele initiale sunt doar numele fisierului si ca al nostru client nu detine momentan niciun segment din acesta). Pe masura ce citeste datele despre fisierele pentru care clientul e seed, acestea sunt trimise la tracker. Dupa ce trimite toate fisierele pe care le detine complet, clientul anunta trackerul ca a terminat de trimis tot ce tine de partea de initializare. 


---> void tracker(int numtasks, int rank): activitatea acestuia consta in 2 bucle: prima este pentru partea de initializare, iar a doua pentru partea de comunicare cu clientii dupa ce acestia incep procesul de descarcare(clientii au voie sa inceapa descarcarea DOAR dupa ce au primit aprobare de la tracker). In bucla 1 se primesc date de la clienti din functia read_file() pana cand toti clientii informeaza trackerul ca au trimis toate datele detinute. Cand trackerul a primit numtasks - 1 astfel de informari, trimite tuturor clientilor un ACK de "start download", dupa care opreste bucla 1, responsabila de initializare.

Bucla 2 se ocupa de comunicarea cu clientii dupa initializare. Trackerul poate gestiona comunicarea prin 4 tipuri de mesaje: 

1) instiintare ca 1 client a descarcat un fisier
2) instiintare ca 1 client a descarcat toate fisierele dorite
3) cerere de swarm/actualizare
4) instiintare ca toti clientii au terminat de descarcat toate fisierele dorite.

Pentru mesajele de tip 1) si 2), trackerul gestioneaza intern mesajele(nu e nevoie sa ofere raspuns clientilor). Pentru tipul 3), trackerul doar comunica datele cerute de client acestuia si il adauga in swarm-ul fisierului. Cand apare mesajul de tip 4), trackerul le spune tuturor clientilor sa inchida threadul de upload, dupa care se inchide si el(termina bucla 2).

---> void *download_thread_func(void *arg): aceasta functie se ocupa de descarcarea fisierelor pentru un client. Pentru fiecare fisier dorit, acesta trimite o cerere de swarm, asteapta raspuns si incepe descarcarea. Pe parcursul descarcarii, la fiecare 10 segmente clientul trimite catre tracker o cerere de actualizare, intrucat swarmul ar putea suferi modificari. Dupa aceea, clientul se uita ce segmente ii lipsesc si incepe sa faca cereri pana cand primeste segmentul dorit si repeta acest procedeu. Pentru o descarcare eficienta si evitarea solicitarii aceluiasi alt client pentru segmente tot timpul, pentru un segment generez un index aleator care va desemna destinatia cererii de segment. Daca nu primesc din prima segmentul dorit, depun cereri si astept raspunsuri printr-o abordare circulara a swarmului pana cand primesc segmentul, caz in care ma opresc. Dupa ce clientul termina de descarcat un fisier, acesta construieste fisierul de output si informeaza trackerul despre descarcare.
De asemenea, clientul trimite o instiintare trackerului si pentru momentul in care a terminat de descarcat toate fisierele dorite.


---> void *upload_thread_func(void *arg): aceasta functie se ocupa de primirea cererilor de segmente de la clienti. Consulta versiunea proprie a fisierului pentru care se solicita un segment, vede daca are posibilitatea sa ofere segmentul solicitat si in functie de situatie trimite un mesaj corespunzator inapoi clientului care a solicitat. Intrucat trackerul nu poate depune cereri de descarcare, threadul de upload poate primi mesaj de la tracker doar atunci cand este nevoie sa se inchida, intrucat toti clientii au terminat de descarcat fisierele dorite.

--->void peer(int numtasks, int rank): aceasta functie apeleaza functia de citire a datelor pentru un client, dupa care asteapta sa primeasca de la tracker ACK-ul pentru a incepe sa descarce(pana nu primeste acest ACK nu se incepe nicio activitate a clientului). Dupa primirea ACK-ului, clientul isi porneste threadurile de upload si download.



